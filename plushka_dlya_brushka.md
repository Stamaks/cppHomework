## -=Все известные мне способы, как тип данных T появляется в классе MyClass=-

1) Создание объекта как поля класса, конструируемого по умолчанию (default constructable):

```template<typename T>
class MyClass {
    T _field;
};

```
2) Создание объекта в стеке метода `Foo` класса `MyClass`:

```template<typename T>
void MyClass<T>::Foo()
{
    // ...
    T obj;
    // ...
}
```

3) Создание контейнера обобщенного типа как поле класса `MyClass`:

```template<typename T>
void MyClass<T>::Foo()
{
    // ...
    Container<T> brushko;
    // ...
}
```

4) Создание функции `Bar`, возвращающей значение обобщенного типа класса `MyClass`:

```template<typename T>
T MyClass<T>::Bar()
{
    // ...
}
```

5) Создание функции `FooBar`, принимающей значение обобщенного типа класса `MyClass`:

```template<typename T>
int MyClass<T>::FooBar(T meow)
{
    // ...
}
```


6) Создание функции `FooBarFoo`, принимающей по ссылке объект обобщенного класса:

```template<typename T>
int MyClass<T>::FooBar(Meow<T>& meow)
{
    // ...
}
```


7) Создание функции `FooBarFooBar`, принимающей указатель на объект обобщенного класса:

```template<typename T>
float MyClass<T>::FooBar(Bork<T>* doggo)
{
    // ...
}
```

Многое из написанного выше можно обощить на указатели на объект обобщенного типа, на контейнеры и массивы обобщенных типов, на указатели на контейнеры и массивы обобщенных типов, на контейнеры и массивы указателей на контейнеры и массивы обобщенных типов и тд, а также на объекты обобщенных типов, функции принимающих и возвращающих всяческие вариации с обобщенными типами... (можно придумать вообще какой нибудь ужас вроде Class1Obj<Class2Obj<Class3Obj<T>>>. Но я буду четко следовать указанию уложиться в одностраничный документ)
